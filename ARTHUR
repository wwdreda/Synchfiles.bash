#!/bin/bash
 
# Help function
usage() {
    echo "Usage: $0 [-i] [-d] path1 path2"
    echo "  -i    Interactive mode. Ask for confirmation before overwriting files."
    echo "  -d    Dry run. Show what would be done, without actually doing it."
    exit 1
}
 
# Parse options
interactive=0
dryrun=0
while getopts "idh" opt; do
    case ${opt} in
        i)
            interactive=1
            ;;
        d)
            dryrun=1
            ;;
        h)
            usage
            ;;
        \?)
            usage
            ;;
    esac
done
shift $((OPTIND -1))
 
# Check number of arguments
if [[ $# -ne 2 ]]; then
    usage
fi
 
# Vérifier si le script est exécuté en tant que root
if [[ $EUID -ne 0 ]]; then
   echo "Ce script doit être exécuté en tant que root"
   exit 1
fi
 
# Vérifier si le nombre correct d'arguments a été fourni
if [[ $# -ne 2 ]]; then
    echo "Usage : $0 path1 path2"
    exit 1
fi
 
# Les chemins vers les systèmes de fichiers A et B
pathA=$1
pathB=$2
 
# Liste des fichiers/répertoires à exclure de la synchronisation
exclusions=("fichier_temporaire.txt" "cache")
 
# Compteur pour les liens symboliques synchronisés
liensSymboliques=0
 
# Variables pour le résumé de la synchronisation
totalFiles=0
filesCopiedFromAtoB=0
filesCopiedFromBtoA=0
conflictsResolved=0
 
# Fonction pour vérifier si un fichier/répertoire doit être exclu
est_exclu() {
    for exclusion in "${exclusions[@]}"; do
        if [[ $1 == *"$exclusion"* ]]; then
            return 0
        fi
    done
    return 1
}

pushToJournal(){
        newJournal="$HOME/.synchro2"
        if [[ ! -f "$newJournal" ]];then 
                touch "$newJournal"
        fi
        path="$1"
        fichier="$2"
        echo "$fichier $(stat -c "%y %U %G %a" "${path}/${fichier}")" >> "$newJournal"
        echo "$fichier has been added to new journal"

         
}
getFromJournal(){
        journal="$HOME/.synchro"
        fichier=$1
        journalInfos="$(grep "^$@ " "$journal")"
        echo "$journalInfos"

}
syncJournal(){
        newJournal="$HOME/.synchro2"
        journal="$HOME/.synchro"
        mv "$newJournal" "$journal"
}


syncFile(){
    local pathA="$1"
    local pathB="$2"
    local relativePath="$3"
    local fichierA="${pathA}/${relativePath}"
    local fichierB="${pathB}/${relativePath}"
    

    echo "shasum A : $(shasum "$fichierA")"
    echo "shasum B : $(shasum "$fichierB")"
    local shasumA=$(shasum "$fichierA" | cut -f1 -d" ")
    local shasumB=$(shasum "$fichierB" | cut -f1 -d" ")

    # Si les deux fichiers ont le même hash SHA
    if [[ "$shasumA" == "$shasumB" ]]; then
        echo "Le fichier $nomFichier est déjà synchronisé."
        # Conflit détecté
        metadataA=$(stat -c "%y %U %G %a" "$fichierA")  # %y pour l'horodatage de modification
        metadataB=$(stat -c "%y %U %G %a" "$fichierB")  # %y pour l'horodatage de modification
        echo -e "metadataA : ${metadataA}\nmetadataB : ${metadataB}"
        ((conflictsResolved++))
        # Comparer le contenu des fichiers
        if [[ "$(stat -c "%y %U %G %a" "$fichierA")" == "$(stat -c "%y %U %G %a" "$fichierB")" ]]; then
            echo "Memes metadatas"
        else
            echo "Les fichiers ont le même contenu, mais diffèrent dans les métadonnées."
            # Résoudre le conflit en copiant les métadonnées du fichier qui est conforme au journal
            if [[ $(shasum "$fichierA") == $(cat "$HOME/.synchro/$(basename $pathA)_$nomFichier") ]]; then
                chown --reference="$fichierA" "$fichierB"
                chmod --reference="$fichierA" "$fichierB"
                touch --reference="$fichierA" "$fichierB"
                echo "Les métadonnées du fichier B ont été mises à jour pour correspondre à celles du fichier A."
            else
                chown --reference="$fichierB" "$fichierA"
                chmod --reference="$fichierB" "$fichierA"
                touch --reference="$fichierB" "$fichierA"
                echo "Les métadonnées du fichier A ont été mises à jour pour correspondre à celles du fichier B."
            fi
            metadataA=$(stat -c "%y %U %G %a" "$fichierA")  # %z pour l'horodatage de modification
            metadataB=$(stat -c "%y %U %G %a" "$fichierB")  # %z pour l'horodatage de modification
            echo -e "metadataA : ${metadataA}\nmetadataB : ${metadataB}"
        fi
    else # les données difèrent
        #syncho les données 
        echo "FichierA : $fichierA"
        echo "FichierB : $fichierB"
        echo "Les fichiers ont un contenu différent. Voici la différence :"
        diff "$fichierA" "$fichierB"
        echo "Veuillez entrer le chemin du fichier que vous souhaitez conserver :"
        read fichierConserve
        if [[ $fichierConserve == $fichierA ]]; then
            if [[ $interactive -eq 1 ]]; then
                echo "Voulez-vous écraser $fichierB avec $fichierA ? (o/n)"
                read response
                if [[ $response != "o" ]]; then
                    echo "Ignorer $fichierA"
                    continue
                fi
            fi
            if [[ $dryrun -eq 1 ]]; then
                echo "Copierait $fichierA vers $fichierB"
            else
                cp -d "$fichierA" "$fichierB"
                echo "Le fichier $nomFichier a été copié de A vers B."
                ((filesCopiedFromAtoB++))
                ((totalFiles++))
            fi
        else
            if [[ $interactive -eq 1 ]]; then
                echo "Voulez-vous écraser $fichierA avec $fichierB ? (o/n)"
                read response
                if [[ $response != "o" ]]; then
                    echo "Ignorer $fichierB"
                    continue
                fi
            fi
            if [[ $dryrun -eq 1 ]]; then
                echo "Copierait $fichierB vers $fichierA"
            else
                cp -d "$fichierB" "$fichierA"
                echo "Le fichier $nomFichier a été copié de B vers A."
                ((filesCopiedFromBtoA++))
                ((totalFiles++))
            fi
        fi
    fi
 
 
}
 
 
 
 
# Fonction pour synchroniser les fichiers
synchroniser() {
    #la on a pathA = /userA/documents/repA/doc1/doc2/
    # et     pathB = /userB/downloads/repB/doc1/doc2/
    #on va regader les fichiers dans pathA puis pathB

    #le problème c'est que dans le journal, ce serait bien de stocker le chemin doc1/doc2/fichier et non le chemin de pathA ...

    #on pourrait donc appeler synchro avec pathA, pathB ("/userX/.../repX"), et relativePath=doc1/doc2/
    #on remplacerait les variables actuelles pathA et pathB par absPathA et absPathB (abs comme absolute)
    #il faudrait remplacer [for fichierA in "$pathA"/*] par [for fichier in $(ls $absPathA)]

    local pathA="$1"
    local pathB="$2"
    local relativePath="$3"
    local absPathA="${pathA}/${relativePath}"
    local absPathB="${pathB}/${relativePath}"

 
    # Parcourir tous les fichiers dans le système de fichiers A
    for fichier in "$(ls ${absPathA})"; do
        local fichierA="${absPathA}/${fichier}"
        echo "fichier examiné : $fichierA"
        if [ -e "$fichierA" ]; then
            echo "le fichier existe !"
        
            # Vérifier si le fichier/répertoire est dans la liste des exclusions
            if est_exclu "$fichierA"; then
                echo "Exclusion : $fichierA"
                continue
            fi
            # Chemin vers le fichier correspondant dans le système de fichiers B
            fichierB="${absPathB}/${fichier}"
            # Vérifier si le fichier existe dans le système de fichiers B
            if [[ -e $fichierB ]]; then
                # Si le fichier est plus grand que 1GB
                if [[ $(stat -c%s "$fichierA") -gt 1073741824 ]]; then
                    echo "Le fichier $nomFichier est très grand et peut prendre du temps à synchroniser."
                    echo "Voulez-vous continuer la synchronisation de ce fichier ? (Oui/Non)"
                    read reponse
                    if [[ $reponse == "Non" ]]; then
                        echo "Exclusion : $fichierA"
                        continue
                    fi
                fi
                # Si les deux fichiers sont des répertoires, descendre récursivement
                if [[ -d $fichierA && -d $fichierB ]]; then
                    echo "c'est un dossier, on appelle synchro avec $pathA $pathB ${relativePath}/${fichier}"
                    synchroniser "$pathA" "$pathB" "${relativePath}/${fichier}"
                # Si les deux fichiers sont des fichiers ordinaires
                elif [[ -f $fichierA && -f $fichierB ]]; then

                    syncFile "$pathA" "$pathB" "${relativePath}/${fichier}"
                fi
            else
                # Copier le fichier de A vers B
                if [[ $interactive -eq 1 ]]; then
                    echo "Voulez-vous copier $fichierA vers $fichierB ? (o/n)"
                    read response
                    if [[ $response != "o" ]]; then
                        echo "Ignorer $fichierA"
                        continue
                    fi
                fi
                if [[ $dryrun -eq 1 ]]; then
                    echo "Copierait $fichierA vers $fichierB"
                else
                    cp -r "$fichierA" "$fichierB"
                    echo "Le fichier $nomFichier a été copié de A vers B."
                    ((filesCopiedFromAtoB++))
                    ((totalFiles++))
                fi
                # Si le fichier est un lien symbolique, incrémenter le compteur
                if [[ -L $fichierA ]]; then
                    ((liensSymboliques++))
                fi
            fi
            # Mettre à jour le journal avec le hachage SHA du fichier synchronisé
            pushToJournal "$pathA" "${relativePath}/${fichier}"
            #echo "$(shasum "$fichierA") $fichierA" > "$HOME/.synchro/$(basename $pathA)_$nomFichier"
            #echo "Synchronisation effectuée le $(date)" >> "$HOME/.synchro/$(basename $pathA)_$nomFichier"
           
        else
            echo "No files found in $pathA" 
        fi
    done
 
    # Parcourir tous les fichiers dans le système de fichiers B
    for fichier in "$(ls ${absPathB})"; do
        local fichierB="${absPathB}/${fichier}"
        echo "fichier examiné : $fichierB"
        if [ -e "$fichierB" ]; then
        echo "le fichier existe !"
            # Vérifier si le fichier/répertoire est dans la liste des exclusions
            if est_exclu "$fichierB"; then
                echo "Exclusion : $fichierB"
                continue
            fi
            # Chemin vers le fichier correspondant dans le système de fichiers A
            fichierA="${absPathA}/${fichier}"
            # Vérifier si le fichier existe dans le système de fichiers A
            if [[ ! -e ${fichierA} ]]; then

                # Si le fichier est plus grand que 1GB
                if [[ $(stat -c%s "$fichierB") -gt 1073741824 ]]; then
                    echo "Le fichier $nomFichier est très grand et peut prendre du temps à synchroniser."
                    echo "Voulez-vous continuer la synchronisation de ce fichier ? (Oui/Non)"
                    read reponse
                    if [[ $reponse == "Non" ]]; then
                        echo "Exclusion : $fichierB"
                        continue
                    fi
                fi
                # Copier le fichier de B vers A
                if [[ $interactive -eq 1 ]]; then
                    echo "Voulez-vous copier $fichierB vers $fichierA ? (o/n)"
                    read response
                    if [[ $response != "o" ]]; then
                        echo "Ignorer $fichierB"
                        continue
                    fi
                fi
                if [[ $dryrun -eq 1 ]]; then
                    echo "Copierait $fichierB vers $fichierA"
                else
                    cp -r "$fichierB" "$fichierA"
                    echo "Le fichier $nomFichier a été copié de B vers A."
                    ((filesCopiedFromBtoA++))
                    ((totalFiles++))
                fi
                # Si le fichier est un lien symbolique, incrémenter le compteur
                if [[ -L $fichierB ]]; then
                    ((liensSymboliques++))
                fi
            fi
            # Mettre à jour le journal avec le hachage SHA du fichier synchronisé
            pushToJournal "$pathA" "${relativePath}/${fichier}"
            #echo "$(shasum "$fichierB") $fichierB" > "$HOME/.synchro/$(basename $pathB)_$nomFichier"
            #echo "Synchronisation effectuée le $(date)" >> "$HOME/.synchro/$(basename $pathB)_$nomFichier"
            echo ""
        else
                echo "No files found in $pathB"
        fi
    done
}
 

 
# Appeler la fonction de synchronisation
synchroniser "$pathA" "$pathB" "."
syncJournal 
# Afficher le résumé de la synchronisation
echo "----------------------------------------"
echo "RÉSUMÉ DE LA SYNCHRONISATION"
echo "----------------------------------------"
echo "Nombre total de fichiers synchronisés : $totalFiles"
echo "Fichiers copiés de A vers B : $filesCopiedFromAtoB"
echo "Fichiers copiés de B vers A : $filesCopiedFromBtoA"
echo "Conflits résolus : $conflictsResolved"
echo "----------------------------------------"
